import java.io.File;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Vector;

public class ProxyTree
{

	private ProxyNode treeRoot;
	private ProxyNode hardwareBranch;
	private ProxyNode softwareBranch;
	private ProxyNode currentNode;
	
	
	public ProxyTree () {
		treeRoot = new ProxyNode("RootProxy", "EH Proxies", "Virtual","");
		//hardwareBranch = new ProxyNode("Hardware", "Hardware Proxies", "Hardware", "");
		//softwareBranch = new ProxyNode("Software", "Software Proxies", "Hardware", "");
		//treeRoot.addSuccessor(hardwareBranch);
		//treeRoot.addSuccessor(softwareBranch);
		//hardwareBranch.addSuccessor(new ProxyNode("Hardware Proxy", "Phidgets","Category",""));
		currentNode = treeRoot;
	}
	public void insertNode (ProxyNode node){
		//TODO: Find an editor that saves in the correct format!!!
		// Unicode without any formatting
		//Or simply write the files differently without any spaces
		ProxyNode predecessorNode;
		
		//if (node.getKind().equals("Hardware Proxy"))
		//{
		  predecessorNode = searchPredecessorNode(treeRoot.getSuccessors().getFirst(), node);
		  System.out.println("PREDECESSORNAME: " + predecessorNode.getName());
		  System.out.println("IM HARDWARE ZWEIG!!");
		//}
		// Now the predecessor of the node is known, so the new node can simply be added to the
			// list of successors
	//	else 
		//{ 	
		  //predecessorNode = searchPredecessorNode(treeRoot.getSuccessors().getLast(), node);
		  //System.out.println("IM SOFTWARE ZWEIG!!");
		//}
		// Add the new node as a successor of the corresponding node
		predecessorNode.getSuccessors().add(node);			
	}

	private ProxyNode searchPredecessorNode (ProxyNode startNode, ProxyNode searchNode) {
		// iterate through the successors to see if the category already exists
		// if not, add a new category and return it
		// otherwise, return the node of that category
		System.out.println("StartNode: " + startNode.getName());
		System.out.println("HAS NEXT?: " + startNode.hasSuccessors());
		//TODO: Fix the problem with the iterators
		// Seems ok, but now a iterator is needed that also inserts nodes
		// or do that in the addSuccessor method of a node!
		for ( Iterator<ProxyNode> i = startNode.getSuccessors().iterator() ; i.hasNext(); )
		{  ////getIterator()
			//ProxyNode compareNode = startNode.getNext();
			System.out.println("In der FOR-Schleife!!!");
			ProxyNode compareKindNode = (ProxyNode) i.next();
			System.out.println("NACH DER ERSTEN ANWEISUNG");
			//check if kind is already there
			if (compareKindNode.getKind().equals(searchNode.getKind()))
			{
				// If the kind already exists, check wether the proxy class is 
				// already there
				{
					for ( Iterator<ProxyNode> it = compareKindNode.getSuccessors().iterator() ; it.hasNext(); )
					{
						ProxyNode compareProxyClassNode = (ProxyNode) it.next();
						if (compareProxyClassNode.getproxyClass().equals(searchNode.getproxyClass()))
							return compareProxyClassNode;					
					}
					// if the ProxyClass does not exist yet, create it
					// and return the newly created node
					ProxyNode newProxyClassNode = new ProxyNode (searchNode.getKind(),searchNode.getproxyClass(),searchNode.getproxyClass(),"");
					compareKindNode.addSuccessor(newProxyClassNode);
					return newProxyClassNode;
				}
			}
			//if (compareNode.getproxyClass().equals(searchNode.getproxyClass()))
			//{	
		//		System.out.println("CompareNode: " + startNode.getName());
		 //   return compareNode;
			//}
		}
		// In the case that no match was found, a new category must be created
		// And the new node is returned
		ProxyNode newKindNode = new ProxyNode (searchNode.getKind(),searchNode.getKind(), searchNode.getKind(), "");
		startNode.addSuccessor(newKindNode);
		// Here a new kind was created
		// Now a new proxClass needs to be created as well
		// This can directly be done because the new node has no successors
		ProxyNode newProxyClassNode = new ProxyNode (searchNode.getKind(),searchNode.getproxyClass(),searchNode.getproxyClass(),"");
		newKindNode.addSuccessor(newProxyClassNode);
		return newProxyClassNode;		
		}
	
	
	//	else if (startAt.hasSuccessors())
		//{
			//if (searchNode(startAt.getSuccessors().getFirst(),toFind)) == null{
			//ListIterator it = 
			//while (it.hasNext()) {
			//searchNode (startAt.getSuccessors().get(it.previousIndex()), "aha");
			
			//}
		//	return null;
	//	}
	//	}
	//	else
		//return null;
	
	public ProxyNode getTreeRoot(){
		return treeRoot;
	}
	
	public ProxyNode getCurrentNode (){
		return currentNode;
	}
}
