/* Copyright  (c) 2003 The Board of Trustees of The Leland Stanford Junior
 * University. All Rights Reserved.
 *
 * See the file LICENSE.txt for information on redistributing this software.
 */

/* $Id: idk_ut_Base.h,v 1.17 2003/06/22 09:30:31 tomoto Exp $ */

#ifndef _IDK_UT_BASE_H_
#define _IDK_UT_BASE_H_

/** @file
 The definitions fundamental for the IDK.
 <p>This file provides basic type definitions, assetion macros, and any other
 tricks necessary for the IDK.  Users do not have to include this file explicitly.
 <p><i>This file must be included at first among all the IDK header files.
 To observe this, IDK developers should follow the types-header-rule described
 in idk_ut_Types.h.</i>
 */

#include <stdio.h>

// to make sure macro WINDOWS defined
#ifndef WINDOWS
# if defined(_WINDOWS) || defined(WIN32) || defined(_WIN32)
#  define WINDOWS
# endif
#endif

// macro to export/import symbols in shared libraries
/** @def IDK_DLLEXPORT Exports a symbol. */
/** @def IDK_DLLIMPORT Imports a symbol from other library. */
#ifdef WINDOWS
# define IDK_DLLEXPORT __declspec(dllexport)
# define IDK_DLLIMPORT __declspec(dllimport)
#else
# define IDK_DLLEXPORT /*empty*/
# define IDK_DLLIMPORT /*empty*/
#endif

/** @def IDK_DECL
 Declares a symbol which belongs to the IDK library.
 */
#ifdef IDK_SOURCE
# define IDK_DECL IDK_DLLEXPORT
#else
# define IDK_DECL IDK_DLLIMPORT
#endif

// Some preliminary checks

#ifdef unix
#if (!defined(_REENTRANT))
#error _REENTRANT must be defined.
#endif
#endif

#ifdef WINDOWS
// precaution to make sure the compiler settings are correct.
// if these settings were wrong, the application might crash.
#if (!defined(_MT) || !defined(_DLL))
#error The code generation setting must be "multithread, DLL" 
#endif
// to suppress undesired and messy warnings
// C4251, C4275 - looks like unavoidable when you use a template class
//                as a parent class of DLL-exported classes.
// C4786 - too long identifier in the debug information.  so what?
// C4355 - there are cases to necessarily initialize member variables
//         with 'this' pointer.  it is definitely safe as long as you
//         only to copy the pointer for later use.
#pragma warning(disable : 4251 4786 4275 4355)
#endif

// OS specific typedefs

#ifdef WINDOWS
#include <windows.h>
#elif unix
#include <errno.h>
#endif

/** @var idk_ut_LockedCounter
 Type of integer which can be used for interlocked operations.
 */
#ifdef WINDOWS
typedef LONG idk_ut_LockedCounter;
#elif unix
typedef int idk_ut_LockedCounter;
#else
# error unsupported platform
#endif

// ansi library's namespace declaration
namespace std {}
using namespace std;

#include <string>
/** String type.
 Using this type as means to keep dynamic string data is encouraged
 rather than a generic abstraction of string data.  This is because
 'const char*' would be still supposed to be much more efficient
 in most cases to handle string.
 */
typedef basic_string<char> idk_string;

/** Byte type (8-bit unsigned integer). */
typedef unsigned char idk_byte;

/** Long type (64-bit signed integer) */
#ifdef WINDOWS
typedef __int64 idk_long;
#else
typedef long long idk_long;
#endif

/** Vector type.
 When you declare a variable of vector type, do not use 'vector<T>'
 directly, but use IDK_UT_VECTOR(T) instead.  This is a precaution
 against sometimes troublesome implementation of STL.
 */
#include <vector>
#define IDK_UT_VECTOR(T) vector<T>

/** List type.
 Use IDK_UT_LIST(T) instead of 'list<T>'.  See IDK_UT_VECTOR(T) also.
 */
#include <list>
#define IDK_UT_LIST(T) list<T>

// assert macros
#ifndef IDK_UT_NOASSERT
/**
 Assertion macro.  This macro is completely eliminated when you define
 IDK_UT_NOASSERT.
 @param cond Condition to assert.
 */
#define IDK_UT_ASSERT(cond) \
	if (!(cond)) idk_ut_assertionFailed(__FILE__, __LINE__, #cond);
/**
 Assertion macro with file name parameter.  This can be used when you don't
 like the file name generated by __FILE__ macro.
 This macro is completely eliminated when you define IDK_UT_NOASSERT.
 @param file File name.
 @param cond Condition to assert.
 */
#define IDK_UT_ASSERT_FILE(file, cond) \
	if (!(cond)) idk_ut_assertionFailed(file, __LINE__, #cond);
/**
 The implementation of assertion failure process.
 In debug version it aborts the probram, in release version it raises
 idk_ut_AssertionFailedException.
 */
void IDK_DECL idk_ut_assertionFailed(const char* file, int line, const char* cond);
#else
#define IDK_UT_ASSERT(cond) /*empty*/
#define IDK_UT_ASSERT_FILE(file, cond) /*empty*/
#endif

// To embed the API version into each obj module.
// This might be helpful to check the consistensy between your already
// compiled application and the IDK library installed on your system.
// Syntax:
//   IDK_API_VERSION:<major version>.<minor version>.<revision>
// Applications need not to be recompiled as long as the <major version>
// and the <minor version> is the same.
static const char* fs_idkAPIVersion = "IDK_API_VERSION:0.5.0";

#endif
